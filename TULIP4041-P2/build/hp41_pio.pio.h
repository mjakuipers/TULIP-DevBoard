// ---------------------------------------------------------------- //
// This file is autogenerated by pioasm version 2.2.0; do not edit! //
// ---------------------------------------------------------------- //

#pragma once

#if !PICO_NO_HARDWARE
#include "hardware/pio.h"
#endif

// ------------- //
// hp41_pio_sync //
// ------------- //

#define hp41_pio_sync_wrap_target 1
#define hp41_pio_sync_wrap 20
#define hp41_pio_sync_pio_version 1

#define hp41_pio_sync_offset_sync_start 0u

static const uint16_t hp41_pio_sync_program_instructions[] = {
    0x288f, //  0: wait   1 gpio, 15      side 1
            //     .wrap_target
    0xf829, //  1: set    x, 9            side 3
    0x380c, //  2: wait   0 gpio, 12      side 3
    0x388c, //  3: wait   1 gpio, 12      side 3
    0x5801, //  4: in     pins, 1         side 3
    0x1842, //  5: jmp    x--, 2          side 3
    0x5802, //  6: in     pins, 2         side 3
    0x9800, //  7: push   noblock         side 3
    0x388d, //  8: wait   1 gpio, 13      side 3
    0x280d, //  9: wait   0 gpio, 13      side 1
    0x288d, // 10: wait   1 gpio, 13      side 1
    0x280d, // 11: wait   0 gpio, 13      side 1
    0x288d, // 12: wait   1 gpio, 13      side 1
    0x200d, // 13: wait   0 gpio, 13      side 0
    0x208d, // 14: wait   1 gpio, 13      side 0
    0xa822, // 15: mov    x, y            side 1
    0x288c, // 16: wait   1 gpio, 12      side 1
    0x4801, // 17: in     pins, 1         side 1
    0x280c, // 18: wait   0 gpio, 12      side 1
    0x0850, // 19: jmp    x--, 16         side 1
    0x288d, // 20: wait   1 gpio, 13      side 1
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program hp41_pio_sync_program = {
    .instructions = hp41_pio_sync_program_instructions,
    .length = 21,
    .origin = -1,
    .pio_version = hp41_pio_sync_pio_version,
#if PICO_PIO_VERSION > 0
    .used_gpio_ranges = 0x1
#endif
};

static inline pio_sm_config hp41_pio_sync_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + hp41_pio_sync_wrap_target, offset + hp41_pio_sync_wrap);
    sm_config_set_sideset(&c, 2, false, false);
    return c;
}

static inline void hp41_pio_sync_program_init(PIO pio, uint sm, uint offset, 
        uint in_base_pin,               // base for input pin ISA and SYNC
        uint sideset_base_pin)          // base for sideset outputs T0_TIME and SYNC_TIME
{
    pio_sm_config c = hp41_pio_sync_program_get_default_config(offset);
    // IO mapping
    sm_config_set_in_pins(&c, in_base_pin);
    sm_config_set_sideset_pins(&c, sideset_base_pin);
    // Configure Input Shift Register ISR
    // Shifting to right matches HP41 bit order
    sm_config_set_in_shift(
        &c,
        true,   // Shift-to-right = true
        true,   // Autopush enabled, 
        29      // Autopush threshold = 29
    );
    // configure the clock divider here
    // not used in the SYNC state machine, runs at full speed
    // float clkdiv = 1;
    // sm_config_set_clkdiv(&c, clkdiv);
    // set correct pin direction for outputs
    pio_sm_set_consecutive_pindirs(pio, sm, sideset_base_pin, 2, true);      // pin direction 2 output pins T0_TIME and SYNC_TIME
    // connect the pins to the PIO for output
    pio_gpio_init(pio, sideset_base_pin);           // T0_TIME
    pio_gpio_init(pio, sideset_base_pin + 1);       // SYNC_TIME
    // load the configuration and jump to the start of the program
    pio_sm_init(pio, sm, offset, &c);
    // and start the pio state machine
    pio_sm_set_enabled(pio, sm, true);
}

#endif

// --------------- //
// hp41_pio_datain //
// --------------- //

#define hp41_pio_datain_wrap_target 1
#define hp41_pio_datain_wrap 4
#define hp41_pio_datain_pio_version 1

#define hp41_pio_datain_offset_data_start 0u

static const uint16_t hp41_pio_datain_program_instructions[] = {
    0x209b, //  0: wait   1 gpio, 27
            //     .wrap_target
    0x208c, //  1: wait   1 gpio, 12
    0x00c4, //  2: jmp    pin, 4
    0x8000, //  3: push   noblock
    0x4f01, //  4: in     pins, 1                [15]
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program hp41_pio_datain_program = {
    .instructions = hp41_pio_datain_program_instructions,
    .length = 5,
    .origin = -1,
    .pio_version = hp41_pio_datain_pio_version,
#if PICO_PIO_VERSION > 0
    .used_gpio_ranges = 0x3
#endif
};

static inline pio_sm_config hp41_pio_datain_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + hp41_pio_datain_wrap_target, offset + hp41_pio_datain_wrap);
    return c;
}

static inline void hp41_pio_datain_program_init(PIO pio, uint sm, uint offset, 
        uint in_base_pin,               // base for input pin DATA / FI
        uint jmp_pin)                   // pin used in jmp, this will be T0_TIME
{
    pio_sm_config c = hp41_pio_datain_program_get_default_config(offset);
    sm_config_set_in_pins(&c, in_base_pin);
    sm_config_set_jmp_pin(&c, jmp_pin);  
    // Configure Input Shift Register ISR
    // Shifting to right matches HP41 bit order
    // for DATA and FI input autopush is enabled for the first 32 DATA bits
    // the remaining 24 bits are forced by a push
    sm_config_set_in_shift(
        &c,
        true,  // Shift-to-right = true
        true,  // Autopush enabled for pushing 32 databits
        32     // Autopush threshold = 32
    );
    // configure the clock to run at 12.5 MHz, clock divider is 10
    // one clockcycle is now 80 ns
    float clkdiv = 10;
    sm_config_set_clkdiv(&c, clkdiv);
    // load the configuration and jump to the start of the program
    pio_sm_init(pio, sm, offset, &c);
    // and start the pio state machine
    pio_sm_set_enabled(pio, sm, true);
}

#endif

// ----------------- //
// hp41_pio_debugout //
// ----------------- //

#define hp41_pio_debugout_wrap_target 0
#define hp41_pio_debugout_wrap 0
#define hp41_pio_debugout_pio_version 1

static const uint16_t hp41_pio_debugout_program_instructions[] = {
            //     .wrap_target
    0x6001, //  0: out    pins, 1
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program hp41_pio_debugout_program = {
    .instructions = hp41_pio_debugout_program_instructions,
    .length = 1,
    .origin = -1,
    .pio_version = hp41_pio_debugout_pio_version,
#if PICO_PIO_VERSION > 0
    .used_gpio_ranges = 0x0
#endif
};

static inline pio_sm_config hp41_pio_debugout_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + hp41_pio_debugout_wrap_target, offset + hp41_pio_debugout_wrap);
    return c;
}

static inline void hp41_pio_debugout_program_init(PIO pio, uint sm, uint offset, 
        uint out_base_pin,              // base for output pin P_DEBUG
        uint sideset_base_pin,          // (not used) base for sideset outputs ISA_OE
        uint set_base_pin,              // (not used) base for set pins
        uint jmp_pin)                   // (not used) pin used in jmp
{
    pio_sm_config c = hp41_pio_debugout_program_get_default_config(offset);
    // set correct pin direction for outputs
    pio_sm_set_consecutive_pindirs(pio, sm, out_base_pin, 1, true);          // pin direction for P_DEBUG
    sm_config_set_out_pins(&c, out_base_pin, 1);    // just using 1 output
    // Configure Output Shift Register OSR
    // Shifting to right matches HP41 bit order
    // for ISA output no autopush is needed
    sm_config_set_out_shift(
        &c,
        true,   // Shift-to-right = true
        true,   // Autopull enabled
        16      // Autopull threshold = 16
    );
    // connect the pins to the PIO for output
    pio_gpio_init(pio, out_base_pin);               // P_DEBUG
    // configure the clock to run at 12.5 MHz, clock divider is 10
    float clkdiv = 10;
    sm_config_set_clkdiv(&c, clkdiv);
    // load the configuration and jump to the start of the program
    pio_sm_init(pio, sm, offset, &c);
    // and start the pio state machine
    pio_sm_set_enabled(pio, sm, true);
}

#endif

// --------------- //
// hp41_pio_isaout //
// --------------- //

#define hp41_pio_isaout_wrap_target 0
#define hp41_pio_isaout_wrap 11
#define hp41_pio_isaout_pio_version 1

#define hp41_pio_isaout_offset_handle_carry 0u
#define hp41_pio_isaout_offset_isa_inst_out 5u
#define hp41_pio_isaout_offset_isa_out 8u

static const uint16_t hp41_pio_isaout_program_instructions[] = {
            //     .wrap_target
    0x80a0, //  0: pull   block           side 0
    0x201a, //  1: wait   0 gpio, 26      side 0
    0x7001, //  2: out    pins, 1         side 1
    0x309a, //  3: wait   1 gpio, 26      side 1
    0x0000, //  4: jmp    0               side 0
    0x80a0, //  5: pull   block           side 0
    0xe029, //  6: set    x, 9            side 0
    0x209b, //  7: wait   1 gpio, 27      side 0
    0x7f01, //  8: out    pins, 1         side 1 [15]
    0x308d, //  9: wait   1 gpio, 13      side 1
    0x1048, // 10: jmp    x--, 8          side 1
    0x301b, // 11: wait   0 gpio, 27      side 1
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program hp41_pio_isaout_program = {
    .instructions = hp41_pio_isaout_program_instructions,
    .length = 12,
    .origin = -1,
    .pio_version = hp41_pio_isaout_pio_version,
#if PICO_PIO_VERSION > 0
    .used_gpio_ranges = 0x3
#endif
};

static inline pio_sm_config hp41_pio_isaout_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + hp41_pio_isaout_wrap_target, offset + hp41_pio_isaout_wrap);
    sm_config_set_sideset(&c, 1, false, false);
    return c;
}

static inline void hp41_pio_isaout_program_init(PIO pio, uint sm, uint offset, 
        uint out_base_pin,              // base for output pin ISA_OUT
        uint sideset_base_pin,          // base for sideset outputs ISA_OE
        uint set_base_pin,              // (not used) base for set pins
        uint jmp_pin)                   // (not used) pin used in jmp
{
    pio_sm_config c = hp41_pio_isaout_program_get_default_config(offset);
    // set correct pin direction for outputs
    pio_sm_set_consecutive_pindirs(pio, sm, out_base_pin, 1, true);          // pin direction for ISA_OUT
    pio_sm_set_consecutive_pindirs(pio, sm, sideset_base_pin, 1, true);      // pin direction for ISA_OE
    sm_config_set_out_pins(&c, out_base_pin, 1);    // just using 1 output
    sm_config_set_sideset_pins(&c, sideset_base_pin);
    // sm_config_set_jmp_pin(&c, jmp_pin);  
    // Configure Output Shift Register OSR
    // Shifting to right matches HP41 bit order
    // for ISA output no autopush is needed
    sm_config_set_out_shift(
        &c,
        true,   // Shift-to-right = true
        false,  // no Autopull
        32      // Autopull threshold = 32, not used here
    );
    // configure the clock to run at 12.5 MHz, clock divider is 10
    // one clockcycle is now 80 ns
    float clkdiv = 10;
    sm_config_set_clkdiv(&c, clkdiv);
    // connect the pins to the PIO for output
    pio_gpio_init(pio, out_base_pin);               // ISA_OUT
    pio_gpio_init(pio, sideset_base_pin);           // ISA_OE
    // load the configuration and jump to the start of the program
    pio_sm_init(pio, sm, offset, &c);
    // and start the pio state machine
    pio_sm_set_enabled(pio, sm, true);
}

#endif

// ---------------- //
// hp41_pio_dataout //
// ---------------- //

#define hp41_pio_dataout_wrap_target 0
#define hp41_pio_dataout_wrap 4
#define hp41_pio_dataout_pio_version 1

static const uint16_t hp41_pio_dataout_program_instructions[] = {
            //     .wrap_target
    0x80a0, //  0: pull   block           side 0
    0x201a, //  1: wait   0 gpio, 26      side 0
    0x7f01, //  2: out    pins, 1         side 1 [15]
    0x308d, //  3: wait   1 gpio, 13      side 1
    0x10c2, //  4: jmp    pin, 2          side 1
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program hp41_pio_dataout_program = {
    .instructions = hp41_pio_dataout_program_instructions,
    .length = 5,
    .origin = -1,
    .pio_version = hp41_pio_dataout_pio_version,
#if PICO_PIO_VERSION > 0
    .used_gpio_ranges = 0x3
#endif
};

static inline pio_sm_config hp41_pio_dataout_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + hp41_pio_dataout_wrap_target, offset + hp41_pio_dataout_wrap);
    sm_config_set_sideset(&c, 1, false, false);
    return c;
}

static inline void hp41_pio_dataout_program_init(PIO pio, uint sm, uint offset, 
        uint out_base_pin,              // base for output pin DATA_OUT
        uint sideset_base_pin,          // base for sideset outputs DATA_OE
        uint jmp_pin)                   // (pin used in jmp, T0_TIME
{
    pio_sm_config c = hp41_pio_dataout_program_get_default_config(offset);
    // set correct pin direction for outputs
    pio_sm_set_consecutive_pindirs(pio, sm, out_base_pin, 1, true);          // pin direction for DATA_OUT
    pio_sm_set_consecutive_pindirs(pio, sm, sideset_base_pin, 1, true);      // pin direction for DATA_OE
    sm_config_set_out_pins(&c, out_base_pin, 1);    // just using 1 output
    sm_config_set_sideset_pins(&c, sideset_base_pin);
    sm_config_set_jmp_pin(&c, jmp_pin);  
    // Configure Output Shift Register OSR
    // Shifting to right matches HP41 bit order
    // for DATA output autopull is needed
    sm_config_set_out_shift(
        &c,
        true,   // Shift-to-right = true (lsb first)
        true,   // Autopull = true
        32      // Autopull threshold = 32
    );
    // configure the clock to run at 12.5 MHz, clock divider is 10
    // one clockcycle is now 80 ns
    float clkdiv = 10;
    sm_config_set_clkdiv(&c, clkdiv);
    // connect the pins to the PIO for output
    pio_gpio_init(pio, out_base_pin);               // DATA_OUT
    pio_gpio_init(pio, sideset_base_pin);           // DATA_OE
    // load the configuration and jump to the start of the program
    pio_sm_init(pio, sm, offset, &c);
    // and start the pio state machine
    pio_sm_set_enabled(pio, sm, true);
}

#endif

// -------------- //
// hp41_pio_fiout //
// -------------- //

#define hp41_pio_fiout_wrap_target 0
#define hp41_pio_fiout_wrap 4
#define hp41_pio_fiout_pio_version 1

#define hp41_pio_fiout_offset_fiout_start 0u

static const uint16_t hp41_pio_fiout_program_instructions[] = {
            //     .wrap_target
    0x80a0, //  0: pull   block
    0x201a, //  1: wait   0 gpio, 26
    0x6f01, //  2: out    pins, 1                [15]
    0x208d, //  3: wait   1 gpio, 13
    0x00c2, //  4: jmp    pin, 2
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program hp41_pio_fiout_program = {
    .instructions = hp41_pio_fiout_program_instructions,
    .length = 5,
    .origin = -1,
    .pio_version = hp41_pio_fiout_pio_version,
#if PICO_PIO_VERSION > 0
    .used_gpio_ranges = 0x3
#endif
};

static inline pio_sm_config hp41_pio_fiout_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + hp41_pio_fiout_wrap_target, offset + hp41_pio_fiout_wrap);
    return c;
}

static inline void hp41_pio_fiout_program_init(PIO pio, uint sm, uint offset, 
        uint out_base_pin,              // base for output pin FI_OE
        uint sideset_base_pin,          // base for sideset outputs not used
        uint jmp_pin)                   // pin used in jmp, T0_TIME
{
    pio_sm_config c = hp41_pio_fiout_program_get_default_config(offset);
    // set correct pin direction for outputs
    pio_sm_set_consecutive_pindirs(pio, sm, out_base_pin, 1, true);          // pin direction for FI_OE    
    // pio_sm_set_consecutive_pindirs(pio, sm, sideset_base_pin, 1, true);      // sideset not used
    sm_config_set_out_pins(&c, out_base_pin, 1);    // just using 1 output
    // sm_config_set_sideset_pins(&c, sideset_base_pin);  // sideset not used
    sm_config_set_jmp_pin(&c, jmp_pin);  
    // Configure Output Shift Register OSR
    // Shifting to right matches HP41 bit order
    // for DATA output autopull is needed
    sm_config_set_out_shift(
        &c,
        true,   // Shift-to-right = true (lsb first)
        true,   // Autopull = true
        32      // Autopull threshold = 32
    );
    // configure the clock to run at 12.5 MHz, clock divider is 10
    // one clockcycle is now 80 ns
    float clkdiv = 10;
    sm_config_set_clkdiv(&c, clkdiv);
    // connect the pins to the PIO for output
    pio_gpio_init(pio, out_base_pin);               // FI_OE
    // pio_gpio_init(pio, sideset_base_pin);           // Dsideset not used
    // load the configuration and jump to the start of the program
    pio_sm_init(pio, sm, offset, &c);
    // and start the pio state machine
    pio_sm_set_enabled(pio, sm, true);
}

#endif

// -------------- //
// hp41_pio_irout //
// -------------- //

#define hp41_pio_irout_wrap_target 2
#define hp41_pio_irout_wrap 7
#define hp41_pio_irout_pio_version 1

#define hp41_pio_irout_offset_ir_high 0u
#define hp41_pio_irout_offset_ir_start 3u
#define hp41_pio_irout_offset_hilo_loop 6u

static const uint16_t hp41_pio_irout_program_instructions[] = {
    0x7021, //  0: out    x, 1            side 1
    0xad42, //  1: nop                    side 0 [13]
            //     .wrap_target
    0xab42, //  2: nop                    side 0 [11]
    0x6021, //  3: out    x, 1            side 0
    0x0021, //  4: jmp    !x, 1           side 0
    0xe026, //  5: set    x, 6            side 0
    0xb042, //  6: nop                    side 1
    0x0046, //  7: jmp    x--, 6          side 0
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program hp41_pio_irout_program = {
    .instructions = hp41_pio_irout_program_instructions,
    .length = 8,
    .origin = -1,
    .pio_version = hp41_pio_irout_pio_version,
#if PICO_PIO_VERSION > 0
    .used_gpio_ranges = 0x0
#endif
};

static inline pio_sm_config hp41_pio_irout_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + hp41_pio_irout_wrap_target, offset + hp41_pio_irout_wrap);
    sm_config_set_sideset(&c, 1, false, false);
    return c;
}

static inline void hp41_pio_irout_program_init(PIO pio, uint sm, uint offset, 
        uint out_base_pin,              // base for output pin, not used
        uint sideset_base_pin,          // base for sideset outputs IR_LED
        uint jmp_pin)                   // not used
{
    pio_sm_config c = hp41_pio_irout_program_get_default_config(offset);
    // set correct pin direction for sideset IR output
    pio_sm_set_consecutive_pindirs(pio, sm, sideset_base_pin, 1, true);         // pin direction for IR_LED
    sm_config_set_sideset_pins(&c, sideset_base_pin);                           // side set is our IR_LED
    // Configure Output Shift Register OSR
    // Shifting to left is our desired bit order, msb sent out first!
    // autopull is needed for constant output
    sm_config_set_out_shift(
        &c,
        false,  // Shift-to-right = false, MSB is sent out first!
        true,   // Autopull = true
        30      // Autopull threshold = 27 !!
                // normally total 27 half-bits are sent
                // plus 3 additional half bits for the inter-frame delay
    );
    // CPU speed is 125.000.000 Hz (125 MHz)
    // target clock rate is 2*32768 Hz
    // resulting clock divider is 1907,3486
    // after testing the clock divider is 1964, resulting is a clock rate of 63.4 kHz
    // the clock period is now 15,7 usecs
    float clkdiv = 1964.0;  // original
    sm_config_set_clkdiv(&c, clkdiv);
    // connect the pins to the PIO for output
    pio_gpio_init(pio, sideset_base_pin);               // IR_LED
    // load the configuration and jump to the start of the program
    pio_sm_init(pio, sm, offset + hp41_pio_irout_offset_ir_start, &c);          // must use the ir_start entry!
    // and start the pio state machine
    pio_sm_set_enabled(pio, sm, true);
}

#endif

